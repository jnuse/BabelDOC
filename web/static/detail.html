<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä»»åŠ¡è¯¦æƒ… - BabelDOC</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <h1 class="nav-title">ğŸ“„ BabelDOC</h1>
            <div class="nav-links">
                <a href="submit.html">æäº¤ä»»åŠ¡</a>
                <a href="tasks.html">ä»»åŠ¡åˆ—è¡¨</a>
            </div>
        </div>
    </nav>

    <div class="container">
        <div class="header-row">
            <h2>ğŸ“Š ä»»åŠ¡è¯¦æƒ…</h2>
            <a href="tasks.html" class="btn btn-secondary">â† è¿”å›åˆ—è¡¨</a>
        </div>

        <div id="loading" class="loading">
            <div class="spinner"></div>
            <p>åŠ è½½ä¸­...</p>
        </div>

        <div id="taskDetail" style="display: none;">
            <div class="detail-card">
                <div class="detail-header">
                    <h3 id="taskFilename"></h3>
                    <span id="taskStatus" class="task-status"></span>
                </div>
                <div class="detail-info">
                    <div class="info-row">
                        <span class="info-label">ä»»åŠ¡ID:</span>
                        <span id="taskId"></span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">è¯­è¨€è½¬æ¢:</span>
                        <span id="taskLang"></span>
                    </div>
                    <div class="info-row" id="pagesRow" style="display: none;">
                        <span class="info-label">é¡µç èŒƒå›´:</span>
                        <span id="taskPages"></span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">åˆ›å»ºæ—¶é—´:</span>
                        <span id="taskCreated"></span>
                    </div>
                    <div class="info-row" id="startedRow" style="display: none;">
                        <span class="info-label">å¼€å§‹æ—¶é—´:</span>
                        <span id="taskStarted"></span>
                    </div>
                    <div class="info-row" id="completedRow" style="display: none;">
                        <span class="info-label">å®Œæˆæ—¶é—´:</span>
                        <span id="taskCompleted"></span>
                    </div>
                    <div class="info-row" id="durationRow" style="display: none;">
                        <span class="info-label">è€—æ—¶:</span>
                        <span id="taskDuration"></span>
                    </div>
                    <div id="errorRow" class="error-box" style="display: none;">
                        <strong>é”™è¯¯ä¿¡æ¯:</strong>
                        <p id="taskError"></p>
                    </div>
                </div>
                <div class="detail-actions">
                    <button id="refreshBtn" class="btn btn-secondary" onclick="loadTask()">ğŸ”„ åˆ·æ–°</button>
                    <div id="downloadBtns" style="display: inline-block;"></div>
                    <button id="deleteBtn" class="btn btn-danger" onclick="deleteTask()">ğŸ—‘ï¸ åˆ é™¤ä»»åŠ¡</button>
                </div>
            </div>

            <div class="log-card">
                <div class="log-header">
                    <h3>ğŸ“ ä»»åŠ¡æ—¥å¿—</h3>
                    <button class="btn btn-secondary btn-sm" onclick="loadLogs()">ğŸ”„ åˆ·æ–°æ—¥å¿—</button>
                </div>
                <div id="logContent" class="log-content">
                    <div class="log-loading">åŠ è½½æ—¥å¿—ä¸­...</div>
                </div>
            </div>
        </div>

        <div id="errorMessage" class="error-message" style="display: none;"></div>
    </div>

    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const taskId = urlParams.get('id');
        let currentTask = null;
        let autoRefreshInterval = null;

        if (!taskId) {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('errorMessage').textContent = 'âŒ æ— æ•ˆçš„ä»»åŠ¡ID';
            document.getElementById('errorMessage').style.display = 'block';
        } else {
            loadTask();
            loadLogs();
            startAutoRefresh();
        }

        async function loadTask() {
            try {
                const response = await fetch(`/api/tasks/detail/${taskId}`);
                if (!response.ok) {
                    throw new Error('ä»»åŠ¡ä¸å­˜åœ¨');
                }

                currentTask = await response.json();
                renderTask(currentTask);

                document.getElementById('loading').style.display = 'none';
                document.getElementById('taskDetail').style.display = 'block';
            } catch (error) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('errorMessage').textContent = 'âŒ ' + error.message;
                document.getElementById('errorMessage').style.display = 'block';
            }
        }

        function renderTask(task) {
            const statusInfo = getStatusInfo(task.status);

            document.getElementById('taskFilename').textContent = task.filename;
            document.getElementById('taskStatus').className = `task-status status-${task.status}`;
            document.getElementById('taskStatus').textContent = `${statusInfo.icon} ${statusInfo.text}`;
            document.getElementById('taskId').textContent = task.id;
            document.getElementById('taskLang').textContent = `${task.lang_in} â†’ ${task.lang_out}`;
            document.getElementById('taskCreated').textContent = new Date(task.created_at).toLocaleString('zh-CN');

            if (task.pages) {
                document.getElementById('pagesRow').style.display = 'flex';
                document.getElementById('taskPages').textContent = task.pages;
            }

            if (task.started_at) {
                document.getElementById('startedRow').style.display = 'flex';
                document.getElementById('taskStarted').textContent = new Date(task.started_at).toLocaleString('zh-CN');
            }

            if (task.completed_at) {
                document.getElementById('completedRow').style.display = 'flex';
                document.getElementById('taskCompleted').textContent = new Date(task.completed_at).toLocaleString('zh-CN');
                
                document.getElementById('durationRow').style.display = 'flex';
                document.getElementById('taskDuration').textContent = getDuration(task.started_at, task.completed_at);
            }

            if (task.error) {
                document.getElementById('errorRow').style.display = 'block';
                document.getElementById('taskError').textContent = task.error;
            }

            // ä¸‹è½½æŒ‰é’®
            const downloadBtns = document.getElementById('downloadBtns');
            downloadBtns.innerHTML = '';
            
            if (task.status === 'success' && task.output_files && task.output_files.length > 0) {
                // å¦‚æœæœ‰å¤šä¸ªè¾“å‡ºæ–‡ä»¶ï¼Œæ˜¾ç¤ºå¤šä¸ªä¸‹è½½æŒ‰é’®
                task.output_files.forEach((file, index) => {
                    const btn = document.createElement('button');
                    btn.className = 'btn btn-success';
                    btn.style.marginRight = '5px';
                    
                    // æ ¹æ®æ–‡ä»¶ååˆ¤æ–­ç±»å‹
                    let label = 'ğŸ“¥ ä¸‹è½½';
                    if (file.includes('dual') || file.includes('bilingual')) {
                        label = 'ğŸ“¥ ä¸‹è½½åŒè¯­ç‰ˆ';
                    } else if (file.includes('mono') || file.includes('monolingual')) {
                        label = 'ğŸ“¥ ä¸‹è½½å•è¯­ç‰ˆ';
                    } else if (task.output_files.length > 1) {
                        label = `ğŸ“¥ ä¸‹è½½æ–‡ä»¶${index + 1}`;
                    }
                    
                    btn.textContent = label;
                    btn.onclick = () => {
                        // ä½¿ç”¨æ–‡ä»¶åç›´æ¥ä¸‹è½½
                        window.location.href = `/api/tasks/download/${task.id}?file=${encodeURIComponent(file)}`;
                    };
                    downloadBtns.appendChild(btn);
                });
            } else if (task.status === 'success' && task.output_file) {
                // å‘åå…¼å®¹ï¼šå¦‚æœåªæœ‰output_fileå­—æ®µ
                const btn = document.createElement('button');
                btn.className = 'btn btn-success';
                btn.textContent = 'ğŸ“¥ ä¸‹è½½ç»“æœ';
                btn.onclick = () => {
                    window.location.href = `/api/tasks/download/${task.id}`;
                };
                downloadBtns.appendChild(btn);
            }
        }

        async function loadLogs() {
            const logContent = document.getElementById('logContent');
            
            try {
                const response = await fetch(`/api/tasks/logs/${taskId}`);
                const logs = await response.text();
                
                if (logs) {
                    logContent.innerHTML = `<pre>${escapeHtml(logs)}</pre>`;
                    // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
                    logContent.scrollTop = logContent.scrollHeight;
                } else {
                    logContent.innerHTML = '<div class="log-empty">æ—¥å¿—æ–‡ä»¶ä¸å­˜åœ¨æˆ–ä»»åŠ¡å°šæœªå¼€å§‹</div>';
                }
            } catch (error) {
                logContent.innerHTML = `<div class="log-error">âŒ åŠ è½½æ—¥å¿—å¤±è´¥: ${error.message}</div>`;
            }
        }

        async function deleteTask() {
            if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªä»»åŠ¡å—ï¼Ÿè¿™å°†åˆ é™¤æ‰€æœ‰ç›¸å…³æ–‡ä»¶å’Œæ—¥å¿—ã€‚')) {
                return;
            }

            try {
                const response = await fetch(`/api/tasks/delete/${taskId}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    alert('âœ… åˆ é™¤æˆåŠŸ');
                    window.location.href = 'tasks.html';
                } else {
                    alert('âŒ åˆ é™¤å¤±è´¥');
                }
            } catch (error) {
                alert('âŒ åˆ é™¤å¤±è´¥: ' + error.message);
            }
        }

        function getStatusInfo(status) {
            const statusMap = {
                'queued': { icon: 'â³', text: 'æ’é˜Ÿä¸­' },
                'running': { icon: 'â–¶ï¸', text: 'è¿è¡Œä¸­' },
                'success': { icon: 'âœ…', text: 'æˆåŠŸ' },
                'failed': { icon: 'âŒ', text: 'å¤±è´¥' }
            };
            return statusMap[status] || { icon: 'â“', text: status };
        }

        function getDuration(start, end) {
            const startTime = new Date(start);
            const endTime = new Date(end);
            const diff = Math.floor((endTime - startTime) / 1000);

            if (diff < 60) return `${diff}ç§’`;
            if (diff < 3600) return `${Math.floor(diff / 60)}åˆ†${diff % 60}ç§’`;
            return `${Math.floor(diff / 3600)}å°æ—¶${Math.floor((diff % 3600) / 60)}åˆ†`;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function startAutoRefresh() {
            autoRefreshInterval = setInterval(() => {
                if (currentTask && (currentTask.status === 'running' || currentTask.status === 'queued')) {
                    loadTask();
                    loadLogs();
                } else if (currentTask && (currentTask.status === 'success' || currentTask.status === 'failed')) {
                    // ä»»åŠ¡å®Œæˆï¼Œåœæ­¢è‡ªåŠ¨åˆ·æ–°
                    clearInterval(autoRefreshInterval);
                }
            }, 3000); // æ¯3ç§’åˆ·æ–°ä¸€æ¬¡
        }

        // é¡µé¢å¸è½½æ—¶æ¸…é™¤å®šæ—¶å™¨
        window.addEventListener('beforeunload', () => {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
            }
        });
    </script>
</body>
</html>
